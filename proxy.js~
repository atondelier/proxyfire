"use strict";

require('colors');
var hp = require('http-proxy');
var util = require('util');
var startingPort = +process.argv[2] || 3000;
var encoding = 'utf8';

/**
 * ProxiedRequest
 * @constructor ProxiedRequest
 */
function ProxiedRequest(req, res, proxy, host, port) {
    if(!this) return new ProxiedRequest(req, res, proxy, host, port);
    this.req = req;
    this.res = res;
    this.proxy = proxy;
    this.host = host;
    this.port = port;
}

ProxiedRequest.prototype.replaceLocation = false;

ProxiedRequest.prototype.replaceContent = false;

ProxiedRequest.prototype.replaceHostWithLocalhost = function replaceHostWithLocalhost(str, requestHost, port) {
    var newHost = '10.20.43.119';
    requestHost = requestHost || this.host;
    port = port || this.port;
    var regexp = new RegExp(requestHost.replace(/\./g, '\\.'), 'g');
    var replacement = newHost + ':' + port;
    var newStr = str.replace(regexp, replacement);
    if(this._isJson) {
        var matches = str.match(regexp);
        console.log(matches ? 'domain matches found for '+requestHost+': ' + matches.length : 'no domain matches found for '+requestHost);
    }
    return newStr;
};

ProxiedRequest.prototype.getHost = function getHost() {
    return this.req.connection.remoteAddress;
};

ProxiedRequest.prototype.getUrl = function getUrl() {
    return this.req.url;
};

ProxiedRequest.prototype.overrideWriteHead = function overrideWriteHead() {

    var self = this,
        req = this.req,
        res = this.res;

    self._oldWriteHead = res.writeHead;
    res.writeHead = function(statusCode, headers) {
        var location = res.getHeader('location');
        res._headArguments = arguments;
        if(location) {
            var newLocation = self.replaceHostWithLocalhost(location);
            console.log('redirection to "'+location.red+'" was replaced with relocation to "'+newLocation.blue+'" (may be the same)');
            res._newLocation = newLocation;
        }
        var isImage = self.isImage();
        var accept = req.headers.accept;
        if(accept && (~accept.search('text/html') || (accept == '*/*' && !isImage))) {
            console.log('text/html document'.blue, accept.yellow);
            res._replaceHost = true;
        } else if(accept && ~accept.search('application/json')) {
            console.log('application/json document'.blue, accept.yellow);
            res._replaceHost = true;
            self._isJson = true;
        } else if(!location) return self._oldWriteHead.apply(res, arguments);  
    };

    return this;
};
ProxiedRequest.prototype.isImage = function isImage() {
    var url = this.getUrl();
    console.log(url, /(png|jpg|jpeg|gif)$/.test(url));
    return /(png|jpg|jpeg|gif)$/.test(url);
};

ProxiedRequest.prototype.overrideWrite = function overrideWriteHead() {

    var self = this,
        req = this.req,
        res = this.res;

    this._content = [];
    self._oldWrite = res.write;
    res.write = function(data) {
        if(res._replaceHost || res._newLocation) {
            var str = data.toString(encoding);
            self._content.push(str);
        } else return self._oldWrite.apply(res, arguments);
    };

    return this;
};

ProxiedRequest.prototype.overrideEnd = function overrideWriteHead() {

    var self = this,
        req = this.req,
        res = this.res;

    self._oldEnd = res.end;
    res.end = function(data) {
        var newData;
        if(res._replaceHost || res._newLocation) {
            if(res._replaceHost) {
                newData = new Buffer(self.replaceHostWithLocalhost(self._content.join('')), encoding);
            }
            if(res._newLocation) {
                newData = new Buffer(self._content.join(''), encoding);
                res.setHeader('location', res._newLocation);
            }
            res.setHeader('Content-Length', newData.length);
            self._oldWriteHead.apply(res, res._headArguments);
            self._oldWrite.call(res, newData);
            self._oldEnd.call(res);
        } else self._oldEnd.apply(res, arguments);
    };

    return this;
};

ProxiedRequest.prototype.plugProxy = function plugProxy() {

    this.proxy.proxyRequest(this.req, this.res, {
        host: this.host,
        port: 80,
        changeOrigin: true
    });

};

ProxiedRequest.prototype.execute = function execute() {

    var self = this;

    this.overrideWriteHead();

    this.overrideWrite();

    this.overrideEnd();

    console.log('IP: ' + this.getHost().grey);
    console.log('proxied request to : '+this.getUrl().green);
        
    this.plugProxy();
};


/**
 * CrossDomainProxiedRequest
 * @constructor CrossDomainProxiedRequest
 * @inherits ProxiedRequest
 */
function CrossDomainProxiedRequest() {
    ProxiedRequest.apply(this, arguments);
}

util.inherits(CrossDomainProxiedRequest, ProxiedRequest);

CrossDomainProxiedRequest.prototype.replaceHostWithLocalhost = function(str) {
    
    var servers = crossDomainProxyServer.servers, i = servers.length, server;
    while(i--) {
        server = servers[i];
        str = ProxiedRequest.prototype.replaceHostWithLocalhost.call(this, str, server.host, server.port);
    }
    return str;
};



/**
 * CrossDomainProxiedRequest
 * @constructor CrossDomainProxiedRequest
 */
function DomainProxyServer(host, port) {
    this.host = host;
    this.port = port;
}

DomainProxyServer.prototype.initialize = function initialize() {
    var self = this;
    this.server = hp.createServer(function proxyRequest(req, res, proxy) {
    
        var proxiedRequest = new CrossDomainProxiedRequest(req, res, proxy, self.host, self.port);
        proxiedRequest.execute();
    
    });
    this.server.listen(self.port);
    console.log('server listening on port '+self.port+' and forwarding to '+self.host);
};



/**
 * CrossDomainProxyServer
 * @constructor CrossDomainProxyServer
 */
function CrossDomainProxyServer(domains) {
    this.domains = domains;
    this.servers = [];
}

CrossDomainProxyServer.prototype.initialize = function initialize() {
    
    var self = this;

    this.domains.forEach(function(domain) {
        var domainProxyServer = self._createServer(domain, startingPort++);
        domainProxyServer.initialize();
        self.servers.push(domainProxyServer);
    });
};

CrossDomainProxyServer.prototype._createServer = function _createServer(host, port) {
    return new DomainProxyServer(host, port);
};


/**
 * Instantiation !!
 */

//TODO: no hosts hardcoding :)
var domains = [
    'www.lafourchette.local',
    'www.eltenedor.local',
    'www.lafourchettesuisse.local',
    'www.thefork.local',
    'www.myfourchette.local',
    'fenix.lafourchette.local',
    'api.lafourchette.local',
    'uploads.lafourchette.local',
    'static.lafourchette.local'
];

var crossDomainProxyServer = new CrossDomainProxyServer(domains);
crossDomainProxyServer.initialize();

